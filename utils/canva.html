<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body, html {
            margin: 0;
            height: 100%;
            overflow: hidden;
        }
        #container {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
            background-color: #e0e0e0;
        }
        #canvas {
            width: 6000px;
            height: 3000px;
            background-color: #f0f0f0;
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
        }
        #draggable {
            width: 100px;
            height: 100px;
            background-color: white;
            position: absolute;
            top: 50px;
            left: 50px;
            border: 1px solid #000;
            cursor: grab;
        }
        #draggable:active {
            cursor: grabbing;
        }
    </style>
    <title>Interactive Canvas</title>
</head>
<body>
    <div id="container">
        <div id="canvas">
            <div id="draggable"></div>
        </div>
    </div>

    <script>
        const container = document.getElementById('container');
        const canvas = document.getElementById('canvas');
        const draggable = document.getElementById('draggable');

        let scale = 1;
        let isDraggingCanvas = false;
        let isDraggingElement = false;
        let startX, startY;
        let canvasStartX, canvasStartY;
        let elementStartX, elementStartY;

        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const scaleAmount = 0.1;
            const previousScale = scale;

            if (e.deltaY < 0) {
                scale += scaleAmount;
            } else {
                scale -= scaleAmount;
            }

            scale = Math.min(Math.max(0.5, scale), 3);

            const rect = canvas.getBoundingClientRect();
            const offsetX = (e.pageX - rect.left) / rect.width;
            const offsetY = (e.pageY - rect.top) / rect.height;

            const newCanvasWidth = canvas.clientWidth * scale;
            const newCanvasHeight = canvas.clientHeight * scale;

            const dx = (newCanvasWidth - canvas.clientWidth * previousScale) * offsetX;
            const dy = (newCanvasHeight - canvas.clientHeight * previousScale) * offsetY;

            canvas.style.transform = `scale(${scale})`;
            canvas.style.left = `${parseFloat(canvas.style.left || 0) - dx}px`;
            canvas.style.top = `${parseFloat(canvas.style.top || 0) - dy}px`;

            constrainCanvas();
        });

        container.addEventListener('mousedown', (e) => {
            if (e.target === canvas || e.target === container) {
                isDraggingCanvas = true;
                startX = e.pageX;
                startY = e.pageY;
                canvasStartX = parseFloat(canvas.style.left || 0);
                canvasStartY = parseFloat(canvas.style.top || 0);
            } else if (e.target === draggable) {
                isDraggingElement = true;
                startX = e.pageX;
                startY = e.pageY;
                elementStartX = draggable.offsetLeft;
                elementStartY = draggable.offsetTop;
            }
        });

        container.addEventListener('mousemove', (e) => {
            if (isDraggingCanvas) {
                const dx = (e.pageX - startX);
                const dy = (e.pageY - startY);

                canvas.style.left = `${canvasStartX + dx}px`;
                canvas.style.top = `${canvasStartY + dy}px`;

                constrainCanvas();
            } else if (isDraggingElement) {
                const dx = (e.pageX - startX) / scale;
                const dy = (e.pageY - startY) / scale;

                draggable.style.left = `${elementStartX + dx}px`;
                draggable.style.top = `${elementStartY + dy}px`;
            }
        });

        container.addEventListener('mouseup', () => {
            isDraggingCanvas = false;
            isDraggingElement = false;
        });

        container.addEventListener('mouseleave', () => {
            isDraggingCanvas = false;
            isDraggingElement = false;
        });

        function constrainCanvas() {
            const containerRect = container.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            const scaledWidth = canvas.clientWidth * scale;
            const scaledHeight = canvas.clientHeight * scale;

            let left = parseFloat(canvas.style.left || 0);
            let top = parseFloat(canvas.style.top || 0);

            if (scaledWidth <= containerRect.width) {
                left = (containerRect.width - scaledWidth) / 2;
            } else {
                if (left > 0) left = 0;
                if (left < containerRect.width - scaledWidth) left = containerRect.width - scaledWidth;
            }

            if (scaledHeight <= containerRect.height) {
                top = (containerRect.height - scaledHeight) / 2;
            } else {
                if (top > 0) top = 0;
                if (top < containerRect.height - scaledHeight) top = containerRect.height - scaledHeight;
            }

            canvas.style.left = `${left}px`;
            canvas.style.top = `${top}px`;
        }
    </script>
</body>
</html>
