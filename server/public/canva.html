<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body,
    html {
      margin: 0;
      height: 100%;
      overflow: hidden;
    }

    #container {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #e0e0e0;
    }

    #canvas {
      background-color: #f0f0f0;
      position: relative;
      transform-origin: 0 0;
    }

    .puzzle-piece {
      border: 1px solid black;
      position: absolute;
      cursor: grab;
      overflow: hidden;
      outline: 1px solid rgba(0, 0, 0, 0);
      /* Hide outline */
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0);
      /* Hide box shadow */
    }

    .locked {
      cursor: default;
    }

    .target-box {
      border: 1px dashed black;
      position: relative;
    }

    #target-container {
      display: grid;
      position: absolute;
      background-color: white;
      overflow: hidden;
    }

    #puzzle-container {
      position: absolute;
    }
  </style>
  <title>Interactive Canvas</title>
</head>

<body>
  <div id="container">
    <div id="canvas">
      <div id="target-container"></div>
      <div id="puzzle-container"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    let currentRoom = '';
    const puzzleTargetMap = {};

    function joinRoom() {
      const queryString = window.location.search;
      const urlParams = new URLSearchParams(queryString);
      const gameId = urlParams.get('gameId');
      if (gameId) {
        socket.emit('joinRoom', gameId);
        currentRoom = gameId;
      }
    }

    async function renderGame() {
      try {
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);
        const gameId = urlParams.get('gameId');

        const url = `/api/1.0/games/${gameId}`;
        const res = await axios.get(url);
        const renderInfo = res.data;

        if (!renderInfo) {
          alert("沒有找到指定的遊戲關卡");
          window.location.href = '/index.html';
        }

        console.log(renderInfo, 123)
        return renderInfo

      } catch (error) {
        alert(error.message)
        alert("請輸入有效的遊戲關卡ID");
        window.location.href = '/index.html';
      }
    }

    const container = document.getElementById('container');
    const canvas = document.getElementById('canvas');
    const targetContainer = document.getElementById('target-container');

    const canvasWidth = 8000;
    const canvasHeight = 6000;
    canvas.style.width = `${canvasWidth}px`;
    canvas.style.height = `${canvasHeight}px`;

    let scale = 1;
    let isDraggingCanvas = false;
    let isDraggingElement = false;
    let startX, startY;
    let canvasStartX, canvasStartY;
    let elementStartX, elementStartY;

    const centerView = () => {
      const containerRect = container.getBoundingClientRect();
      const targetContainerRect = targetContainer.getBoundingClientRect();

      const offsetX = (containerRect.width / 2) - (targetContainerRect.left + targetContainerRect.width / 2);
      const offsetY = (containerRect.height / 2) - (targetContainerRect.top + targetContainerRect.height / 2);

      canvas.style.left = `${offsetX}px`;
      canvas.style.top = `${offsetY}px`;
    };

    container.addEventListener('wheel', (e) => {
      e.preventDefault();
      const scaleAmount = 0.1;
      const previousScale = scale;

      if (e.deltaY < 0) {
        scale += scaleAmount;
      } else {
        scale -= scaleAmount;
      }

      scale = Math.min(Math.max(0.3, scale), 3);

      const rect = canvas.getBoundingClientRect();
      const offsetX = (e.pageX - rect.left) / rect.width;
      const offsetY = (e.pageY - rect.top) / rect.height;

      const newCanvasWidth = canvas.clientWidth * scale;
      const newCanvasHeight = canvas.clientHeight * scale;

      const dx = (newCanvasWidth - canvas.clientWidth * previousScale) * offsetX;
      const dy = (newCanvasHeight - canvas.clientHeight * previousScale) * offsetY;

      canvas.style.transform = `scale(${scale})`;
      canvas.style.left = `${parseFloat(canvas.style.left || 0) - dx}px`;
      canvas.style.top = `${parseFloat(canvas.style.top || 0) - dy}px`;

      constrainCanvas();
    });

    container.addEventListener('mousedown', (e) => {
      if (e.target === canvas || e.target === container || e.target.parentNode === targetContainer
        || e.target.parentNode.parentNode === targetContainer) {
        e.target.style.cursor = 'move';
        isDraggingCanvas = true;
        startX = e.pageX;
        startY = e.pageY;
        canvasStartX = parseFloat(canvas.style.left || 0);
        canvasStartY = parseFloat(canvas.style.top || 0);
      }
    });

    container.addEventListener('mousemove', (e) => {
      if (isDraggingCanvas) {
        const dx = (e.pageX - startX);
        const dy = (e.pageY - startY);

        canvas.style.left = `${canvasStartX + dx}px`;
        canvas.style.top = `${canvasStartY + dy}px`;

        constrainCanvas();
      } else if (isDraggingElement) {
        const dx = (e.pageX - startX) / scale;
        const dy = (e.pageY - startY) / scale;

        let newLeft = elementStartX + dx;
        let newTop = elementStartY + dy;

        newLeft = Math.max(0, Math.min(newLeft, canvasWidth - e.target.clientWidth));
        newTop = Math.max(0, Math.min(newTop, canvasHeight - e.target.clientHeight));

        e.target.style.left = `${newLeft}px`;
        e.target.style.top = `${newTop}px`;
      }
    });

    container.addEventListener('mouseup', (e) => {
      e.target.style.cursor = 'default';
      isDraggingCanvas = false;
      isDraggingElement = false;
    });

    container.addEventListener('mouseleave', (e) => {
      e.target.style.cursor = 'default';
      isDraggingCanvas = false;
      isDraggingElement = false;
    });

    function constrainCanvas() {
      const containerRect = container.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      const scaledWidth = canvas.clientWidth * scale;
      const scaledHeight = canvas.clientHeight * scale;

      let left = parseFloat(canvas.style.left || 0);
      let top = parseFloat(canvas.style.top || 0);

      if (scaledWidth <= containerRect.width) {
        left = (containerRect.width - scaledWidth) / 2;
      } else {
        if (left > 0) left = 0;
        if (left < containerRect.width - scaledWidth) left = containerRect.width - scaledWidth;
      }

      if (scaledHeight <= containerRect.height) {
        top = (containerRect.height - scaledHeight) / 2;
      } else {
        if (top > 0) top = 0;
        if (top < containerRect.height - scaledHeight) top = containerRect.height - scaledHeight;
      }

      canvas.style.left = `${left}px`;
      canvas.style.top = `${top}px`;
    }


    function getImageDimensions(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          resolve({ width: img.width, height: img.height, src: url });
        };
        img.onerror = reject;
        img.src = url;
      });
    }

    async function renderGame2(gameInfo) {
      const {
        game_id, title, question_img_url, owner_id,
        row_qty, col_qty, difficulty, mode,
        puzzles,
        is_public, is_open_when_owner_not_in,
        play_duration, is_completed, completed_at
      } = gameInfo;

      const img = await getImageDimensions(question_img_url)
      const maxDimension = 1500;
      let scale = 1;

      if (img.width > img.height) {
        scale = maxDimension / img.width;
      } else {
        scale = maxDimension / img.height;
      }

      const scaledWidth = img.width * scale;
      const scaledHeight = img.height * scale;
      img.scale = scale;

      const rows = parseInt(row_qty);
      const cols = parseInt(col_qty);
      const pieceWidth = scaledWidth / cols;
      const pieceHeight = scaledHeight / rows;

      const pieces = [];
      const puzzleContainer = document.getElementById('puzzle-container');
      puzzleContainer.innerHTML = '';
      Object.keys(puzzleTargetMap).forEach(key => delete puzzleTargetMap[key]);

      puzzles.forEach((puzzleInfo) => {
        const {
          puzzle_id: pieceId, target_id: targetId, top_ratio, left_ratio,
          is_locked, locked_by, locked_color, locked_at, z_index
        } = puzzleInfo;
        puzzleTargetMap[targetId] = pieceId;


        const piece = document.createElement('div');
        piece.id = pieceId;
        piece.className = `puzzle-piece ${is_locked ? 'locked' : ''}`;
        piece.style.width = `${pieceWidth}px`;
        piece.style.height = `${pieceHeight}px`;
        piece.style.backgroundImage = `url(${img.src})`;
        piece.style.backgroundSize = `${scaledWidth}px ${scaledHeight}px`;
        piece.style.backgroundPosition = `-${(targetId - 1) % cols * pieceWidth}px -${Math.floor((targetId - 1) / cols) * pieceHeight}px`;
        piece.style.top = `${canvasHeight * top_ratio / 100}px`;
        piece.style.left = `${canvasWidth * left_ratio / 100}px`;

        piece.style.zIndex = z_index;
        puzzleContainer.appendChild(piece);
        pieces.push(piece);
      })

      createTargetBoxes(img, rows, cols, pieceWidth, pieceHeight);
      addDragAndDrop();
    }

    function createTargetBoxes(img, rows, cols, pieceWidth, pieceHeight) {
      const targetContainer = document.getElementById('target-container');
      targetContainer.style.border = '5px solid black';
      targetContainer.innerHTML = '';
      targetContainer.style.gridTemplateColumns = `repeat(${cols}, ${pieceWidth}px)`;
      targetContainer.style.gridTemplateRows = `repeat(${rows}, ${pieceHeight}px)`;
      targetContainer.style.width = `${cols * pieceWidth}px`;
      targetContainer.style.height = `${rows * pieceHeight}px`;

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const targetBox = document.createElement('div');
          targetBox.id = 'target' + (row * cols + col + 1);
          targetBox.className = 'target-box';
          targetBox.style.width = `${pieceWidth}px`;
          targetBox.style.height = `${pieceHeight}px`;
          targetBox.style.backgroundImage = `url(${img.src})`;
          targetBox.style.backgroundSize = `${img.width * img.scale}px ${img.height * img.scale}px`;
          targetBox.style.backgroundPosition = `-${col * pieceWidth}px -${row * pieceHeight}px`;
          targetBox.style.opacity = 0.2;
          targetContainer.appendChild(targetBox);
        }
      }
      targetContainer.style.left = `${(canvasWidth - targetContainer.clientWidth) / 2}px`;
      targetContainer.style.top = `${(canvasHeight - targetContainer.clientHeight) / 2}px`;
    }

    function addDragAndDrop() {
      const puzzlePieces = document.querySelectorAll('.puzzle-piece');
      const targetBoxes = document.querySelectorAll('.target-box');
      let offsetX, offsetY, selectedPiece;

      puzzlePieces.forEach(piece => {
        piece.addEventListener('mousedown', onMouseDown);
      });

      function onMouseDown(e) {
        if (e.target.dataset.isLocked === 'true') return;
        selectedPiece = e.target;
        selectedPiece.style.zIndex = '10';
        selectedPiece.style.cursor = 'grabbing';
        const rect = selectedPiece.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      }

      function onMouseMove(e) {
        if (!selectedPiece) return;
        const canvasRect = canvas.getBoundingClientRect();
        const dx = (e.clientX - canvasRect.left - offsetX) / scale;
        const dy = (e.clientY - canvasRect.top - offsetY) / scale;
        selectedPiece.style.left = `${dx}px`;
        selectedPiece.style.top = `${dy}px`;
        socket.emit('movePiece', {
          room: currentRoom,
          puzzleId: selectedPiece.id,
          left: selectedPiece.style.left,
          top: selectedPiece.style.top,
        });
      }

      function onMouseUp() {
        if (!selectedPiece) return;
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        selectedPiece.style.cursor = 'grab';

        targetBoxes.forEach(target => {
          const targetId = parseInt(target.id.replace('target', ''));
          const pieceId = selectedPiece.id;
          if (isNearTarget(selectedPiece, target) && puzzleTargetMap[targetId] === pieceId) {
            const overlapRatio = calculateOverlap(selectedPiece, target);
            if (overlapRatio >= 0.7) {
              centerInTarget(selectedPiece, target);
              selectedPiece.dataset.isLocked = 'true';
              selectedPiece.style.zIndex = '2';
              selectedPiece.classList.add('locked');
              selectedPiece.removeEventListener('mousedown', onMouseDown);

              socket.emit('lockPiece', {
                room: currentRoom,
                puzzleId: selectedPiece.id,
                targetId: target.id,
                left: selectedPiece.style.left,
                top: selectedPiece.style.top,
                zIndex: selectedPiece.style.zIndex
              });
            } else {
              selectedPiece.style.zIndex = '5';
            }
          }
        });
        selectedPiece = null;
      }

      function isNearTarget(element, target) {
        const rect1 = element.getBoundingClientRect();
        const rect2 = target.getBoundingClientRect();

        const isInHorizontalBound = rect1.left < rect2.right && rect1.right > rect2.left;
        const isInVerticalBound = rect1.top < rect2.bottom && rect1.bottom > rect2.top;

        return isInHorizontalBound && isInVerticalBound;
      }

      function calculateOverlap(element, target) {
        const rect1 = element.getBoundingClientRect();
        const rect2 = target.getBoundingClientRect();

        const overlapWidth = Math.min(rect1.right, rect2.right) - Math.max(rect1.left, rect2.left);
        const overlapHeight = Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top, rect2.top);

        if (overlapWidth <= 0 || overlapHeight <= 0) {
          return 0;
        }

        const overlapArea = overlapWidth * overlapHeight;
        const elementArea = rect1.width * rect1.height;

        return overlapArea / elementArea;
      }

      function centerInTarget(element, target) {
        target.innerHTML = '';
        target.appendChild(element);
        target.style.width = '100%';
        target.style.height = '100%';
        target.style.opacity = 1;
        target.style.border = 'none';
        element.style.border = 'none';
        element.style.position = 'absolute';
        element.style.left = '50%';
        element.style.top = '50%';
        element.style.transform = 'translate(-50%, -50%)';
      }

      socket.on('movePiece', (data) => {
        if (data.room === currentRoom) {
          const piece = document.getElementById(data.puzzleId);
          if (piece) {
            piece.style.left = data.left;
            piece.style.top = data.top;
          }
        }
      });

      socket.on('lockPiece', (data) => {
        if (data.room === currentRoom) {
          const piece = document.getElementById(data.puzzleId);
          const target = document.getElementById(data.targetId);
          if (piece && target) {
            target.appendChild(piece);
            target.style.opacity = 1;
            target.style.border = 'none';
            piece.style.border = 'none';
            piece.style.left = '50%';
            piece.style.top = '50%';
            piece.style.zIndex = data.zIndex;
            piece.style.transform = 'translate(-50%, -50%)';
            piece.dataset.isLocked = 'true';
            piece.classList.add('locked');
            piece.removeEventListener('mousedown', onMouseDown);
          }
        }
      });
    }

    async function main() {
      joinRoom();
      const renderInfo = await renderGame();
      await renderGame2(renderInfo);
      centerView();
    }
    main();

  </script>
</body>

</html>